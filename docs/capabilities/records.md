---
sidebar_position: 0
---

# Records

C# 9 introduced [record types](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/record) into the language, while C# 10 added support for struct records as well.

While these are great, they also have a few drawbacks:
- They are only available [from Unity 2021](https://docs.unity3d.com/2021.3/Documentation/Manual/CSharpCompiler.html).
- They rely on properties, which are implemented via methods accessing fields. Our records allow you to use fields
  directly.
- They cannot extend other classes, only other records.
- Record structs cannot have mutable fields.
- You cannot make a partial class or struct that was generated by an external tool into a record. For example, this 
  is impossible:

  ```cs title=Foo.generated.cs
  public partial struct Foo {
    // ...
  }
  ```

  ```cs title=Foo.user.cs
  public partial record Foo();
  ```

Our implementation of records provide you with a wide variety of use cases and customization options to suit 
every situation.

### Basic syntax

A record is any class or struct, annotated with the `[Record]` attribute. Conceptually you can think about records as immutable data containers which have [structural equality semantics](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/equality-comparisons#value-equality) (also known as value equality).

```cs title="Simple record definition"
using GenerationAttributes;
using System.Collections.Immutable;

[Record]
public class Person {
  public readonly string FirstName, LastName;
  public readonly int Age;
  public readonly ImmutableArray<Person> Children;
}
```

The compiler analyzes the type at compile time and by default:
- Generates a constructor that assigns all fields (read-only or mutable) and properties.
- Implements the `IEquatable<Person>` interface and provides the necessary `Equals` and `GetHashCode` methods.
- Generates a `ToString` method that renders `IEnumerable`s properly.

This is how the default generated code looks like for the `Person` class defined above.

:::note
The generated code is formatted by the Roslyn compiler.
:::

```cs title=Person.1.partials.cs
// ReSharper disable all
using GenerationAttributes;
using System.Collections.Immutable;

public partial class Person : System.IEquatable<Person>
{
    // Generated by: RecordAttribute
    public Person(string FirstName, string LastName, int Age, System.Collections.Immutable.ImmutableArray<Person> Children)
    {
        this.FirstName = FirstName;
        this.LastName = LastName;
        this.Age = Age;
        this.Children = Children;
    }

    public override string ToString() => "Person(FirstName: " + FirstName + ", LastName: " + LastName + ", Age: " + Age + ", Children: [" + GenerationAttributes.Helpers.enumerableToString(Children) + "])";

    public override int GetHashCode()
    {
        unchecked
        {
            var hashCode = 0;
            hashCode = (hashCode * 397) ^ (FirstName == null ? 0 : FirstName.GetHashCode());
            hashCode = (hashCode * 397) ^ (LastName == null ? 0 : LastName.GetHashCode());
            hashCode = (hashCode * 397) ^ (int)Age;
            hashCode = (hashCode * 397) ^ Children.GetHashCode();
            return hashCode;
        }
    }

    public bool Equals(Person other)
    {
        if (ReferenceEquals(null, other))
            return false;
        if (ReferenceEquals(this, other))
            return true;
        return System.Object.Equals(FirstName, other.FirstName) && System.Object.Equals(LastName, other.LastName) && Age == other.Age && Children.Equals(other.Children);
    }

    public override bool Equals(object obj)
    {
        if (ReferenceEquals(null, obj))
            return false;
        if (ReferenceEquals(this, obj))
            return true;
        return obj is Person && Equals((Person)obj);
    }

    public static bool operator ==(Person left, Person right) => System.Object.Equals(left, right);
    public static bool operator !=(Person left, Person right) => !System.Object.Equals(left, right);
}
```

## Customization

While the default settings for the `[Record]` usually suffice, records can customized in multiple ways.

### ConstructorFlags

The `ConstructorFlags` parameter allows you to change what kind of constructors are generated.

There are 4 types of constructors: `primary`, `apply`, `copy` and `with`.

```cs title="Definition of ConstructorFlags"
[Flags] public enum ConstructorFlags {
  /// <summary> Does not generate any constructors </summary>
  None        = 0,
  /// <summary> Generates basic constructor </summary>
  Constructor = 1 << 0,
  /// <summary> Generates basic constructor and `apply` constructor </summary>
  Apply       = (1 << 1) | Constructor,
  /// <summary> Generates basic constructor and `copy` extension </summary>
  Copy        = (1 << 2) | Constructor,
  /// <summary> Generates basic constructor and `with` extensions </summary>
  Withers     = (1 << 3) | Constructor,
  /// <summary> 
  /// Generates basic constructor, `copy` extension, `with` extensions and `apply` 
  /// constructor.
  /// </summary>
  All         = Constructor | Apply | Copy | Withers,
}
```

#### Primary Constructor

This is your standard constructor that you invoke using `new Person(...)`.

#### Apply Constructor

A static method named `a` (short for `apply`) that is generated in:
- if the type is non-generic: in the same type.
- if the type is generic: in a partial non-generic type.

  :::info
  For example, `Person<TValue>` would get its apply constructor generated in the `Person` type.
  :::

```cs title="Apply Constructor"
[Record(ConstructorFlags.Apply)]
public partial class Person {
  // ...
}

var person = Person.a(/* ... */);
```

:::tip
Apply constructors are very useful when the type is generic. For example:

```cs
[Record(ConstructorFlags.Apply)]
public partial class SetOf3<TValue> {
  public readonly TValue Value1, Value2, Value3;
}
```

If you would use the default constructor, you have to specify the generic type manually:
```cs
var set = new SetOf3<Person>(person1, person2, person3);
```

However, the apply constructor allows you to infer the generic type from the constructor arguments:
```cs
var set = SetOf3.a(person1, person2, person3);
```

This is especially useful, when the generic type is something long or complicated, like `ImmutableHashSet<Either<Person, Animal>>`.
:::

#### Copy constructor

Copy constructors allow you to easily make copies of existing records with one or more fields changed.

```cs
[Record(ConstructorFlags.Copy)] 
public partial class Person {
  public readonly string FirstName, LastName;
  public readonly int Age;
}

var p = new Person("John", "Smith", 30);
var p2 = p.copy(FirstName: "Steve", Age: 42);
Assert.Equal(p2, new Person("Steve", "Smith", 42));
```

:::note
If you pass a nullable value (such as `null` for reference types and `(System.Nullable<A>) null` for value types) the copy constructor will keep the original field value. Thus if you want to be able to set the field value to `null`, you need to use either a regular, apply or `with` constructor.
:::

#### With constructors

If you specify `ConstructorFlags.Withers`, with-constructors will be generated. They are a specialized case of copy constructors which only replace a single field.

```cs
[Record(ConstructorFlags.Withers)] 
public partial class Person {
  public readonly string FirstName, LastName;
  public readonly int Age;
}

var p = new Person("John", "Smith", 30);
var p2 = p.withFirstName("Steve").withAge(42);
Assert.Equal(p2, new Person("Steve", "Smith", 42));
```

:::info
Whether to use `Withers` or `Copy` is usually a matter of preference. If you are changing a single field, the `with*` constructor will be a tiny bit faster, as it does not have to determine which fields you want to actually replace.
:::

#### Specifying multiple ConstructorFlags

You can specify any combination of `ConstructorFlags`:
```cs
[Record(ConstructorFlags.Copy | ConstructorFlags.Apple)] 
public partial class Person {
  // ...
}
```

### Generate* Settings

There are 3 settings that can toggle generation of different parts of code:
- `GenerateToString` - controls whether `ToString` should be generated.

  This is useful when you want to provide your own implementation of `ToString`.

  ```cs title="Record a with manually written 'ToString()'"
  [Record(GenerateToString = false)]
  public readonly partial struct Vector2 {
    public readonly float X, Y;

    public override string ToString() => $"({X}, {Y})";
  }
  ```

- `GenerateEquality` - controls whether the type should implement `IEquatable` and whether `Equals` should be generated.

  :::tip
  This is mostly useful when extending code which was generated by some 3rd-party tool which already generated the equality code.
  :::

- `GenerateGetHashCode` - controls whether `GetHashCode` should be generated.

  :::tip
  This is mostly useful when extending code which was generated by some 3rd-party tool which already generated the hashing code.
  :::

### Excluding Fields

If you want to prevent a field from being included into the set of record fields, there are two ways to do that.

You can either use the `[RecordExclude]` attribute:
```cs
[Record]
public partial class People {
    public readonly ImmutableList<Person> Everyone;

    [RecordExclude] int? _TotalAge;
    public int TotalAge => _TotalAge ??= Everyone.Select(p => p.Age).Sum();
}
```

Or you can list the fields you want to exclude as the parameters to the attribute:
```cs
[Record(ExcludeNames = new []{ nameof(_TotalAge) })]
public partial class People {
    public readonly ImmutableList<Person> Everyone;

    int? _TotalAge;
    public int TotalAge => _TotalAge ??= Everyone.Select(p => p.Age).Sum();
}
```
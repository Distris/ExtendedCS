"use strict";(self.webpackChunkcsharp_extended_compiler=self.webpackChunkcsharp_extended_compiler||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docsSidebar":[{"type":"link","label":"Introduction","href":"/ExtendedCS/docs/intro","docId":"intro"},{"type":"link","label":"Supported Targets","href":"/ExtendedCS/docs/supported-targets","docId":"supported-targets"},{"type":"link","label":"Code Generation vs Transformation","href":"/ExtendedCS/docs/generation-and-transformation/","docId":"generation-and-transformation/index"},{"type":"category","label":"Capabilities","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Record","href":"/ExtendedCS/docs/capabilities/records","docId":"capabilities/records"},{"type":"link","label":"GenConstructor","href":"/ExtendedCS/docs/capabilities/gen-constructor","docId":"capabilities/gen-constructor"},{"type":"link","label":"LazyProperty","href":"/ExtendedCS/docs/capabilities/lazy-property","docId":"capabilities/lazy-property"},{"type":"category","label":"Implicits","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Use Case: Dependency Injection","href":"/ExtendedCS/docs/capabilities/implicits/dependency-injection","docId":"capabilities/implicits/dependency-injection"},{"type":"link","label":"Use Case: CallerData","href":"/ExtendedCS/docs/capabilities/implicits/caller-data","docId":"capabilities/implicits/caller-data"},{"type":"link","label":"Use Case: Library Design","href":"/ExtendedCS/docs/capabilities/implicits/library-design","docId":"capabilities/implicits/library-design"}],"href":"/ExtendedCS/docs/capabilities/implicits/"},{"type":"category","label":"Macros","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"C# Compilation Process","href":"/ExtendedCS/docs/capabilities/macros/csharp-compilation-process","docId":"capabilities/macros/csharp-compilation-process"},{"type":"category","label":"Attribute-Based Macros","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"MacroException","href":"/ExtendedCS/docs/capabilities/macros/attribute-based/macro-exception","docId":"capabilities/macros/attribute-based/macro-exception"},{"type":"link","label":"ExpressionMacro","href":"/ExtendedCS/docs/capabilities/macros/attribute-based/expression-macro","docId":"capabilities/macros/attribute-based/expression-macro"},{"type":"link","label":"StatementMacro","href":"/ExtendedCS/docs/capabilities/macros/attribute-based/statement-macro","docId":"capabilities/macros/attribute-based/statement-macro"}],"href":"/ExtendedCS/docs/capabilities/macros/attribute-based/"}],"href":"/ExtendedCS/docs/capabilities/macros/"}],"href":"/ExtendedCS/docs/capabilities/"}]},"docs":{"capabilities/gen-constructor":{"id":"capabilities/gen-constructor","title":"GenConstructor","description":"GenConstructor] is a weaker case of [[Record].","sidebar":"docsSidebar"},"capabilities/implicits/caller-data":{"id":"capabilities/implicits/caller-data","title":"Use Case: CallerData","description":"C# provides us with [CallerMemberNameAttribute], [CallerFilePathAttribute] and [CallerLineNumberAttribute] to get compile time information about where the function is being called from.","sidebar":"docsSidebar"},"capabilities/implicits/dependency-injection":{"id":"capabilities/implicits/dependency-injection","title":"Use Case: Dependency Injection","description":"Lets say we have this code:","sidebar":"docsSidebar"},"capabilities/implicits/index":{"id":"capabilities/implicits/index","title":"Implicits","description":"Implicits are a feature that we have ported from the Scala language. They are a way to resolve function parameter values without providing them explicitly.","sidebar":"docsSidebar"},"capabilities/implicits/library-design":{"id":"capabilities/implicits/library-design","title":"Use Case: Library Design","description":"Having implicit resolution in the language opens us new interesting paths on how to design developer-friendly libraries in C#.","sidebar":"docsSidebar"},"capabilities/index":{"id":"capabilities/index","title":"Compiler Capabilities","description":"This section describes what our extended C# compiler is capable of.","sidebar":"docsSidebar"},"capabilities/lazy-property":{"id":"capabilities/lazy-property","title":"LazyProperty","description":"[LazyProperty] makes the property calculated only on first access and then cached as a field in the type.","sidebar":"docsSidebar"},"capabilities/macros/attribute-based/expression-macro":{"id":"capabilities/macros/attribute-based/expression-macro","title":"ExpressionMacro","description":"[ExpressionMacro] is an attribute that allows you to replace the invocation of a function with a specified body that returns an expression.","sidebar":"docsSidebar"},"capabilities/macros/attribute-based/index":{"id":"capabilities/macros/attribute-based/index","title":"Attribute-Based Macros","description":"Attribute-based macros are attached to types or methods.","sidebar":"docsSidebar"},"capabilities/macros/attribute-based/macro-exception":{"id":"capabilities/macros/attribute-based/macro-exception","title":"MacroException","description":"When you use an attribute-based macro the body of the function gets replaced. However, the C# compiler still requires us to provide some body for the function, even if it will get thrown out.","sidebar":"docsSidebar"},"capabilities/macros/attribute-based/statement-macro":{"id":"capabilities/macros/attribute-based/statement-macro","title":"StatementMacro","description":"TODO","sidebar":"docsSidebar"},"capabilities/macros/csharp-compilation-process":{"id":"capabilities/macros/csharp-compilation-process","title":"C# Compilation Process","description":"Compilation Process","sidebar":"docsSidebar"},"capabilities/macros/index":{"id":"capabilities/macros/index","title":"Macros","description":"Macros are programs that are ran during the compilation. These programs get access to the source code that is being compiled and can do anything that a regular program does. They can:","sidebar":"docsSidebar"},"capabilities/records":{"id":"capabilities/records","title":"Record","description":"C# 9 introduced record types into the language, while C# 10 added support for struct records as well.","sidebar":"docsSidebar"},"generation-and-transformation/index":{"id":"generation-and-transformation/index","title":"Code Generation vs Transformation","description":"Our compiler can do two things:","sidebar":"docsSidebar"},"intro":{"id":"intro","title":"Introduction","description":"TODO","sidebar":"docsSidebar"},"supported-targets":{"id":"supported-targets","title":"Supported Targets","description":"TODO: any .NET framework or Core project + Unity","sidebar":"docsSidebar"}}}')}}]);
"use strict";(self.webpackChunkcsharp_extended_compiler=self.webpackChunkcsharp_extended_compiler||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docsSidebar":[{"type":"link","label":"Introduction","href":"/docs/intro","docId":"intro"},{"type":"link","label":"TODO: Supported Targets","href":"/docs/supported-targets","docId":"supported-targets"},{"type":"link","label":"Code Generation vs Transformation","href":"/docs/generation-and-transformation/","docId":"generation-and-transformation/index"},{"type":"category","label":"Capabilities","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Record","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"RecordType","href":"/docs/capabilities/record/record-type","docId":"capabilities/record/record-type"}],"href":"/docs/capabilities/record/"},{"type":"link","label":"GenConstructor","href":"/docs/capabilities/gen-constructor","docId":"capabilities/gen-constructor"},{"type":"link","label":"GenToString","href":"/docs/capabilities/gen-to-string","docId":"capabilities/gen-to-string"},{"type":"link","label":"LazyProperty","href":"/docs/capabilities/lazy-property","docId":"capabilities/lazy-property"},{"type":"link","label":"PublicAccessor","href":"/docs/capabilities/public-accessor","docId":"capabilities/public-accessor"},{"type":"link","label":"Exhaustive Matching","href":"/docs/capabilities/exhaustive-matching","docId":"capabilities/exhaustive-matching"},{"type":"category","label":"Implicit Parameter Resolution","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Use Case: Dependency Injection","href":"/docs/capabilities/implicits/dependency-injection","docId":"capabilities/implicits/dependency-injection"},{"type":"link","label":"Use Case: CallerData","href":"/docs/capabilities/implicits/caller-data","docId":"capabilities/implicits/caller-data"},{"type":"link","label":"Use Case: Library Design","href":"/docs/capabilities/implicits/library-design","docId":"capabilities/implicits/library-design"}],"href":"/docs/capabilities/implicits/"}],"href":"/docs/capabilities/"},{"type":"category","label":"Macros","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Inlining","href":"/docs/macros/inlining","docId":"macros/inlining"},{"type":"category","label":"Attribute-Based Macros","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"MacroException","href":"/docs/macros/attribute-based/macro-exception","docId":"macros/attribute-based/macro-exception"},{"type":"link","label":"ExpressionMacro","href":"/docs/macros/attribute-based/expression-macro","docId":"macros/attribute-based/expression-macro"},{"type":"link","label":"StatementMacro","href":"/docs/macros/attribute-based/statement-macro","docId":"macros/attribute-based/statement-macro"},{"type":"link","label":"VarMacro","href":"/docs/macros/attribute-based/var-macro","docId":"macros/attribute-based/var-macro"},{"type":"link","label":"Parameters and Functions","href":"/docs/macros/attribute-based/parameters-and-functions","docId":"macros/attribute-based/parameters-and-functions"},{"type":"link","label":"CompilationErrorMacro","href":"/docs/macros/attribute-based/compilation-error-macro","docId":"macros/attribute-based/compilation-error-macro"},{"type":"link","label":"Use Cases","href":"/docs/macros/attribute-based/use-cases","docId":"macros/attribute-based/use-cases"}],"href":"/docs/macros/attribute-based/"},{"type":"category","label":"Scriban-Based Macros","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"One-Off Macros","href":"/docs/macros/scriban-based/one-off-macros","docId":"macros/scriban-based/one-off-macros"}],"href":"/docs/macros/scriban-based/"},{"type":"link","label":"TODO: C#-Based Macros","href":"/docs/macros/csharp-based/","docId":"macros/csharp-based/index"},{"type":"link","label":"C# Compilation Process","href":"/docs/macros/csharp-compilation-process","docId":"macros/csharp-compilation-process"}],"href":"/docs/macros/"},{"type":"category","label":"Macro Library","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"General","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"DelegateToInterface","href":"/docs/macro-library/general/delegate-to-interface","docId":"macro-library/general/delegate-to-interface"},{"type":"link","label":"EmptyTypeEquality","href":"/docs/macro-library/general/empty-type-equality","docId":"macro-library/general/empty-type-equality"},{"type":"link","label":"EnumUnion","href":"/docs/macro-library/general/enum-union","docId":"macro-library/general/enum-union"},{"type":"link","label":"ExtractXMLDocIntoConst","href":"/docs/macro-library/general/extract-xml-doc-into-const","docId":"macro-library/general/extract-xml-doc-into-const"},{"type":"link","label":"GenEnumFlags","href":"/docs/macro-library/general/gen-enum-flags","docId":"macro-library/general/gen-enum-flags"},{"type":"link","label":"TODO: GenEnumXMLDocConstStrings","href":"/docs/macro-library/general/gen-enum-xml-doc-const-strings","docId":"macro-library/general/gen-enum-xml-doc-const-strings"},{"type":"link","label":"TODO: LambdaInterfaceImplFor","href":"/docs/macro-library/general/lambda-interface-impl-for","docId":"macro-library/general/lambda-interface-impl-for"},{"type":"link","label":"TODO: LambdaInterface","href":"/docs/macro-library/general/lambda-interface","docId":"macro-library/general/lambda-interface"},{"type":"link","label":"Mixin","href":"/docs/macro-library/general/mixin","docId":"macro-library/general/mixin"},{"type":"link","label":"TODO: Singleton","href":"/docs/macro-library/general/singleton","docId":"macro-library/general/singleton"},{"type":"link","label":"TODO: SubsetEnum","href":"/docs/macro-library/general/subset-enum","docId":"macro-library/general/subset-enum"},{"type":"link","label":"TODO: Union","href":"/docs/macro-library/general/union","docId":"macro-library/general/union"}],"href":"/docs/macro-library/general/"},{"type":"category","label":"Unity","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"TODO: EnumTypeAFor","href":"/docs/macro-library/unity/enum-type-a-for","docId":"macro-library/unity/enum-type-a-for"},{"type":"link","label":"TODO: EnumTypeA","href":"/docs/macro-library/unity/enum-type-a","docId":"macro-library/unity/enum-type-a"}],"href":"/docs/macro-library/unity/"}],"href":"/docs/macro-library/"}]},"docs":{"capabilities/exhaustive-matching":{"id":"capabilities/exhaustive-matching","title":"Exhaustive Matching","description":"In modern languages like Scala, Rust, Kotlin or F#, it is trivial to declare discriminated unions, also known as algebraic data types (ADTs).","sidebar":"docsSidebar"},"capabilities/gen-constructor":{"id":"capabilities/gen-constructor","title":"GenConstructor","description":"GenConstructor] allows you to use the constructor generation facilities of [[Record] on any type.","sidebar":"docsSidebar"},"capabilities/gen-to-string":{"id":"capabilities/gen-to-string","title":"GenToString","description":"GenToString] allows you to use the ToString generation facilities of [[Record] on any type.","sidebar":"docsSidebar"},"capabilities/implicits/caller-data":{"id":"capabilities/implicits/caller-data","title":"Use Case: CallerData","description":"C# provides us with [CallerMemberNameAttribute], [CallerFilePathAttribute] and [CallerLineNumberAttribute] to get compile time information about where the function is being called from.","sidebar":"docsSidebar"},"capabilities/implicits/dependency-injection":{"id":"capabilities/implicits/dependency-injection","title":"Use Case: Dependency Injection","description":"Lets say we have this code:","sidebar":"docsSidebar"},"capabilities/implicits/index":{"id":"capabilities/implicits/index","title":"Implicit Parameter Resolution","description":"Implicit parameter resolution is a feature that we have ported from the Scala language. They are a way to resolve function parameter values without providing them explicitly.","sidebar":"docsSidebar"},"capabilities/implicits/library-design":{"id":"capabilities/implicits/library-design","title":"Use Case: Library Design","description":"Having implicit resolution in the language opens us new interesting paths on how to design developer-friendly libraries in C#.","sidebar":"docsSidebar"},"capabilities/index":{"id":"capabilities/index","title":"Capabilities","description":"This section describes what our extended C# compiler is capable of.","sidebar":"docsSidebar"},"capabilities/lazy-property":{"id":"capabilities/lazy-property","title":"LazyProperty","description":"[LazyProperty] makes the property calculated only on first access and then cached as a field in the type.","sidebar":"docsSidebar"},"capabilities/public-accessor":{"id":"capabilities/public-accessor","title":"PublicAccessor","description":"[PublicAccessor] generates a public getter in a partial type definition that allows accessing a private / protected field.","sidebar":"docsSidebar"},"capabilities/record/index":{"id":"capabilities/record/index","title":"Record","description":"C# 9 introduced record types into the language, while C# 10 added support for struct records as well.","sidebar":"docsSidebar"},"capabilities/record/record-type":{"id":"capabilities/record/record-type","title":"RecordType","description":"Currently if the type that is included in the record is generated by the compiler (for example, from a macro), the compiler will not be able to compile such a record without us providing additional information.","sidebar":"docsSidebar"},"generation-and-transformation/index":{"id":"generation-and-transformation/index","title":"Code Generation vs Transformation","description":"Our compiler can do two things:","sidebar":"docsSidebar"},"intro":{"id":"intro","title":"Introduction","description":"Introducing ExtendedCS: Turbocharge Your C# Development with Our Advanced Compiler","sidebar":"docsSidebar"},"macro-library/general/delegate-to-interface":{"id":"macro-library/general/delegate-to-interface","title":"DelegateToInterface","description":"Usable on: class, struct","sidebar":"docsSidebar"},"macro-library/general/empty-type-equality":{"id":"macro-library/general/empty-type-equality","title":"EmptyTypeEquality","description":"Usable on: struct, class","sidebar":"docsSidebar"},"macro-library/general/enum-union":{"id":"macro-library/general/enum-union","title":"EnumUnion","description":"Usable on: struct, class","sidebar":"docsSidebar"},"macro-library/general/extract-xml-doc-into-const":{"id":"macro-library/general/extract-xml-doc-into-const","title":"ExtractXMLDocIntoConst","description":"Usable on: field, property, class, struct","sidebar":"docsSidebar"},"macro-library/general/gen-enum-flags":{"id":"macro-library/general/gen-enum-flags","title":"GenEnumFlags","description":"Creates an enum type with [Flags] attribute for the given enum type.","sidebar":"docsSidebar"},"macro-library/general/gen-enum-xml-doc-const-strings":{"id":"macro-library/general/gen-enum-xml-doc-const-strings","title":"TODO: GenEnumXMLDocConstStrings","description":"","sidebar":"docsSidebar"},"macro-library/general/index":{"id":"macro-library/general/index","title":"General","description":"These macros work on any C# project, as opposed to Unity specific macros.","sidebar":"docsSidebar"},"macro-library/general/lambda-interface":{"id":"macro-library/general/lambda-interface","title":"TODO: LambdaInterface","description":"","sidebar":"docsSidebar"},"macro-library/general/lambda-interface-impl-for":{"id":"macro-library/general/lambda-interface-impl-for","title":"TODO: LambdaInterfaceImplFor","description":"","sidebar":"docsSidebar"},"macro-library/general/mixin":{"id":"macro-library/general/mixin","title":"Mixin","description":"Usable on: struct, class","sidebar":"docsSidebar"},"macro-library/general/singleton":{"id":"macro-library/general/singleton","title":"TODO: Singleton","description":"","sidebar":"docsSidebar"},"macro-library/general/subset-enum":{"id":"macro-library/general/subset-enum","title":"TODO: SubsetEnum","description":"","sidebar":"docsSidebar"},"macro-library/general/union":{"id":"macro-library/general/union","title":"TODO: Union","description":"","sidebar":"docsSidebar"},"macro-library/index":{"id":"macro-library/index","title":"Macro Library","description":"Scriban-based and C#-based macros allow us to do a lot of things that would otherwise only be possible as compiler extensions.","sidebar":"docsSidebar"},"macro-library/unity/enum-type-a":{"id":"macro-library/unity/enum-type-a","title":"TODO: EnumTypeA","description":"Usable on: enum","sidebar":"docsSidebar"},"macro-library/unity/enum-type-a-for":{"id":"macro-library/unity/enum-type-a-for","title":"TODO: EnumTypeAFor","description":"Usable on: struct, class","sidebar":"docsSidebar"},"macro-library/unity/index":{"id":"macro-library/unity/index","title":"Unity","description":"These macros are Unity specific and rely on types defined in the UnityEngine assembly to work.","sidebar":"docsSidebar"},"macros/attribute-based/compilation-error-macro":{"id":"macros/attribute-based/compilation-error-macro","title":"CompilationErrorMacro","description":"Fails the compilation with the specified message.","sidebar":"docsSidebar"},"macros/attribute-based/expression-macro":{"id":"macros/attribute-based/expression-macro","title":"ExpressionMacro","description":"[ExpressionMacro] is an attribute that allows you to replace the invocation of a function with a specified body that returns an expression.","sidebar":"docsSidebar"},"macros/attribute-based/index":{"id":"macros/attribute-based/index","title":"Attribute-Based Macros","description":"Attribute-based macros are attached to types or methods.","sidebar":"docsSidebar"},"macros/attribute-based/macro-exception":{"id":"macros/attribute-based/macro-exception","title":"MacroException","description":"When you use an attribute-based macro the body of the function gets replaced. However, the C# compiler still requires us to provide some body for the function, even if it will get thrown out.","sidebar":"docsSidebar"},"macros/attribute-based/parameters-and-functions":{"id":"macros/attribute-based/parameters-and-functions","title":"Parameters and Functions","description":"Expression, statement and var macros share some of the parameters and functions that you can use in them.","sidebar":"docsSidebar"},"macros/attribute-based/statement-macro":{"id":"macros/attribute-based/statement-macro","title":"StatementMacro","description":"StatementMacro] is very similar to [[ExpressionMacro], however where [ExpressionMacro] produces expressions, [StatementMacro] produces statements.","sidebar":"docsSidebar"},"macros/attribute-based/use-cases":{"id":"macros/attribute-based/use-cases","title":"Use Cases","description":"Expression and statement macros are incredibly useful in these scenarios.","sidebar":"docsSidebar"},"macros/attribute-based/var-macro":{"id":"macros/attribute-based/var-macro","title":"VarMacro","description":"VarMacro] is sort of a blend between [[ExpressionMacro] and [StatementMacro].","sidebar":"docsSidebar"},"macros/csharp-based/index":{"id":"macros/csharp-based/index","title":"TODO: C#-Based Macros","description":"-Based Macros","sidebar":"docsSidebar"},"macros/csharp-compilation-process":{"id":"macros/csharp-compilation-process","title":"C# Compilation Process","description":"Compilation Process","sidebar":"docsSidebar"},"macros/index":{"id":"macros/index","title":"Macros","description":"Macros are programs that are ran during the compilation. These programs get access to the source code that is being compiled and can do anything that a regular program does. They can:","sidebar":"docsSidebar"},"macros/inlining":{"id":"macros/inlining","title":"Inlining","description":"This is a general overview of inlining, which is a process of taking a function call and putting the code from that function directly at the call-site, instead of calling a function. After inlining the inlined function does not exist anymore in the code.","sidebar":"docsSidebar"},"macros/scriban-based/index":{"id":"macros/scriban-based/index","title":"Scriban-Based Macros","description":"You can write your own logic using the scriban template engine with [AttributeMacro].","sidebar":"docsSidebar"},"macros/scriban-based/one-off-macros":{"id":"macros/scriban-based/one-off-macros","title":"One-Off Macros","description":"When using scriban-based macros with [AttributeMacro] you need to define a custom attribute that you can then attach to a class, struct, enum, field, property or method.","sidebar":"docsSidebar"},"supported-targets":{"id":"supported-targets","title":"TODO: Supported Targets","description":"TODO: any .NET framework or Core project + Unity","sidebar":"docsSidebar"}}}')}}]);
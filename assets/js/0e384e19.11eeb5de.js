"use strict";(self.webpackChunkcsharp_extended_compiler=self.webpackChunkcsharp_extended_compiler||[]).push([[9671],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),m=o,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||a;return n?r.createElement(h,i(i({ref:t},c),{},{components:n})):r.createElement(h,i({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var d=2;d<a;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9881:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var r=n(7462),o=(n(7294),n(3905));const a={sidebar_position:1},i="Introduction",s={unversionedId:"intro",id:"intro",title:"Introduction",description:"Introducing ExtendedCS: Turbocharge Your C# Development with Our Advanced Compiler",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/docs/intro",draft:!1,editUrl:"https://github.com/distris/ExtendedCS/tree/main/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"docsSidebar",next:{title:"TODO: Supported Targets",permalink:"/docs/supported-targets"}},l={},d=[{value:"Key Benefits of ExtendedCS",id:"key-benefits-of-extendedcs",level:2},{value:"The Birth of ExtendedCS",id:"the-birth-of-extendedcs",level:2}],c={toc:d},p="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Introducing ExtendedCS: Turbocharge Your C# Development with Our Advanced Compiler")),(0,o.kt)("p",null,"In today's fast-paced technology landscape, efficiency and productivity are crucial to the success of your business. ExtendedCS is a cutting-edge compiler extension, designed to elevate your C# development experience by augmenting the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/dotnet/roslyn"},"official open-source C# compiler, Roslyn"),". Our primary focus is to help companies streamline their software development process and reduce long-term maintenance costs."),(0,o.kt)("h2",{id:"key-benefits-of-extendedcs"},"Key Benefits of ExtendedCS"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Seamless Integration with Unity and .NET Projects:")," ExtendedCS empowers both ",(0,o.kt)("a",{parentName:"p",href:"/docs/supported-targets"},"Unity and regular .NET framework/.NET core projects")," to utilize the latest C# version, unlocking access to the most recent language advancements for your development team.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Improved Developer Experience:")," Our ",(0,o.kt)("a",{parentName:"p",href:"/docs/capabilities/implicits/"},"implicit parameter resolution")," feature enables the creation of libraries that provide an enhanced developer experience, making them more user-friendly and less prone to misuse.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Advanced Abstractions and Optimization:")," ",(0,o.kt)("a",{parentName:"p",href:"/docs/macros/"},"Macros")," in ExtendedCS allow you to introduce abstractions that transcend vanilla C# limitations and optimize your code for peak performance.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Reduced Boilerplate Code with Ready-to-Use Macro Library"),": Tools like ",(0,o.kt)("a",{parentName:"p",href:"/docs/capabilities/record/"},(0,o.kt)("inlineCode",{parentName:"a"},"[Record]")),", ",(0,o.kt)("a",{parentName:"p",href:"/docs/capabilities/lazy-property"},(0,o.kt)("inlineCode",{parentName:"a"},"[LazyProperty]")),", ",(0,o.kt)("a",{parentName:"p",href:"/docs/capabilities/public-accessor"},(0,o.kt)("inlineCode",{parentName:"a"},"PublicAccessor")),", ",(0,o.kt)("a",{parentName:"p",href:"/docs/capabilities/exhaustive-matching"},"exhaustive matching")," minimize boilerplate code, while our ",(0,o.kt)("a",{parentName:"p",href:"/docs/macro-library/"},"library of ready-to-use macros")," for common tasks simplifies the development process. This not only increases productivity but also boosts the overall happiness of your engineering team.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Enhanced Code Quality"),": ExtendedCS reduces friction in the development process, encouraging software engineers to implement robust solutions rather than resorting to quick, dirty code. This significantly lowers long-term maintenance costs and ensures a more sustainable software architecture."))),(0,o.kt)("p",null,"Embrace ExtendedCS today and propel your C# development to new heights. Give your team the tools they need to excel, and experience the tangible benefits of increased productivity and code quality."),(0,o.kt)("h2",{id:"the-birth-of-extendedcs"},"The Birth of ExtendedCS"),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Our Journey and the Heart Behind ExtendedCS")),(0,o.kt)("p",null,"In this section, we'd like to share with you the story of how ExtendedCS came to be, the passion behind its development, and the challenges we faced along the way, providing an in-depth account of our experiences."),(0,o.kt)("p",null,"Our journey began in 2013 when we started making games with the Unity game engine. Despite its use of C#, we quickly realized that Unity wasn't up to date with the latest version of the language. As developers coming from languages like Scala, F#, Idris, and Rust, we found ourselves longing for the innovative features we had grown accustomed to in those languages."),(0,o.kt)("p",null,"Then, one day, we discovered a community effort to integrate the new Roslyn compiler with Unity. Excited by this prospect, we jumped on board and updated our codebase to utilize the latest C# features. To our delight, our productivity soared."),(0,o.kt)("p",null,"However, we still faced some challenges. Our adoption of functional programming tools meant that we created numerous one-off types, each tailored to a specific aspect of our domain. Writing and updating these types was not only time-consuming but also quite boring. We tried using tools like ReSharper and Rider to generate the code, but we still had to manually update the generated code whenever we added a new field to a type. This process was error-prone, as it was easy to forget to regenerate all of the code or make a subtle mistake in the update."),(0,o.kt)("p",null,"That's when we had an idea: since we were already replacing the default compiler and Roslyn was open-source, why not create our own extensions and incorporate them into Roslyn? Inspired by this thought, we rolled up our sleeves and started hacking away at the compiler, eventually giving birth to the first versions of ExtendedCS."),(0,o.kt)("p",null,"Over time, we developed patterns to eliminate boilerplate code, such as ",(0,o.kt)("inlineCode",{parentName:"p"},"[LazyProperty]")," for caching expensive computations and ",(0,o.kt)("inlineCode",{parentName:"p"},"[PublicAccessor]")," to prevent exposing mutable Unity-serialized fields while reducing the need to write public getters for private fields."),(0,o.kt)("p",null,"We designed our game logic using discriminated unions (also known as algebraic data types), which are a powerful way to represent different variations of data within a single type. However, we faced challenges with C#'s switch statement, specifically its non-exhaustiveness. This limitation meant that the compiler did not enforce the handling of all possible cases of a given type, potentially leading to unhandled cases or errors when new cases were introduced later. The non-exhaustive nature of the switch statement resulted in less reliable code, as it was easy to overlook a case during development or maintenance. Thus to address this issue, we developed the ","[Matcher]"," pattern."),(0,o.kt)("p",null,"In our codebase, we utilized the ",(0,o.kt)("inlineCode",{parentName:"p"},"Either")," type to avoid ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.c2.com/?DontUseExceptionsForFlowControl"},"problems with using exceptions for control flow")," (similar to ",(0,o.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/result/"},"Rust's ",(0,o.kt)("inlineCode",{parentName:"a"},"Result")),") and wondered if we could incorporate something like the ",(0,o.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/result/#the-question-mark-operator-"},(0,o.kt)("inlineCode",{parentName:"a"},"?")," operator")," into our code. Although C# offered LINQ expressions, they allocated new objects, which increased garbage collection and hindered performance\u2014significant concerns in game development. Our experience with ",(0,o.kt)("inlineCode",{parentName:"p"},"[LazyProperty]")," led us to explore code rewriting, ultimately giving birth to the first macros."),(0,o.kt)("p",null,"We continued to innovate, introducing ergonomic log statements that didn't allocate objects when the log level was off. During a code migration, we identified the need for logic in our macros, giving rise to scriban-based macros."),(0,o.kt)("p",null,"Over time, we found that some macros had become increasingly complex, making them cumbersome to write in scriban. This led us to implement C#-based macros, which provided the full power and expressiveness of C# to macro authors."),(0,o.kt)("p",null,"After over seven years of rigorous testing and using the compiler ourselves, we're excited to share ExtendedCS with the world, granting you access to the same productivity-enhancing tools we've enjoyed."),(0,o.kt)("p",null,"With love, the ExtendedCS team."))}u.isMDXComponent=!0}}]);
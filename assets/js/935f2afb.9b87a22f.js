"use strict";(self.webpackChunkcsharp_extended_compiler=self.webpackChunkcsharp_extended_compiler||[]).push([[53],{1109:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docsSidebar":[{"type":"link","label":"TODO: Introduction","href":"/ExtendedCS/docs/intro","docId":"intro"},{"type":"link","label":"TODO: Supported Targets","href":"/ExtendedCS/docs/supported-targets","docId":"supported-targets"},{"type":"link","label":"Code Generation vs Transformation","href":"/ExtendedCS/docs/generation-and-transformation/","docId":"generation-and-transformation/index"},{"type":"category","label":"Compiler Capabilities","collapsible":true,"collapsed":true,"items":[{"type":"category","label":"Record","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"RecordType","href":"/ExtendedCS/docs/capabilities/record/record-type","docId":"capabilities/record/record-type"}],"href":"/ExtendedCS/docs/capabilities/record/"},{"type":"link","label":"GenConstructor","href":"/ExtendedCS/docs/capabilities/gen-constructor","docId":"capabilities/gen-constructor"},{"type":"link","label":"GenToString","href":"/ExtendedCS/docs/capabilities/gen-to-string","docId":"capabilities/gen-to-string"},{"type":"link","label":"LazyProperty","href":"/ExtendedCS/docs/capabilities/lazy-property","docId":"capabilities/lazy-property"},{"type":"link","label":"Exhaustive Matching","href":"/ExtendedCS/docs/capabilities/exhaustive-matching","docId":"capabilities/exhaustive-matching"},{"type":"category","label":"Implicits","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Use Case: Dependency Injection","href":"/ExtendedCS/docs/capabilities/implicits/dependency-injection","docId":"capabilities/implicits/dependency-injection"},{"type":"link","label":"Use Case: CallerData","href":"/ExtendedCS/docs/capabilities/implicits/caller-data","docId":"capabilities/implicits/caller-data"},{"type":"link","label":"Use Case: Library Design","href":"/ExtendedCS/docs/capabilities/implicits/library-design","docId":"capabilities/implicits/library-design"}],"href":"/ExtendedCS/docs/capabilities/implicits/"},{"type":"category","label":"Macros","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Inlining","href":"/ExtendedCS/docs/capabilities/macros/inlining","docId":"capabilities/macros/inlining"},{"type":"category","label":"Attribute-Based Macros","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"MacroException","href":"/ExtendedCS/docs/capabilities/macros/attribute-based/macro-exception","docId":"capabilities/macros/attribute-based/macro-exception"},{"type":"link","label":"ExpressionMacro","href":"/ExtendedCS/docs/capabilities/macros/attribute-based/expression-macro","docId":"capabilities/macros/attribute-based/expression-macro"},{"type":"link","label":"StatementMacro","href":"/ExtendedCS/docs/capabilities/macros/attribute-based/statement-macro","docId":"capabilities/macros/attribute-based/statement-macro"},{"type":"link","label":"Parameters and Functions","href":"/ExtendedCS/docs/capabilities/macros/attribute-based/parameters-and-functions","docId":"capabilities/macros/attribute-based/parameters-and-functions"},{"type":"link","label":"Use Cases","href":"/ExtendedCS/docs/capabilities/macros/attribute-based/use-cases","docId":"capabilities/macros/attribute-based/use-cases"}],"href":"/ExtendedCS/docs/capabilities/macros/attribute-based/"},{"type":"link","label":"TODO: Scriban-Based Macros","href":"/ExtendedCS/docs/capabilities/macros/scriban-based/","docId":"capabilities/macros/scriban-based/index"},{"type":"link","label":"TODO: C#-Based Macros","href":"/ExtendedCS/docs/capabilities/macros/csharp-based/","docId":"capabilities/macros/csharp-based/index"},{"type":"link","label":"C# Compilation Process","href":"/ExtendedCS/docs/capabilities/macros/csharp-compilation-process","docId":"capabilities/macros/csharp-compilation-process"}],"href":"/ExtendedCS/docs/capabilities/macros/"}],"href":"/ExtendedCS/docs/capabilities/"},{"type":"category","label":"Macro Library","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"TODO: Singleton","href":"/ExtendedCS/docs/macro-library/singleton","docId":"macro-library/singleton"}],"href":"/ExtendedCS/docs/macro-library/"}]},"docs":{"capabilities/exhaustive-matching":{"id":"capabilities/exhaustive-matching","title":"Exhaustive Matching","description":"In modern languages like Scala, Rust, Kotlin or F#, it is trivial to declare discriminated unions, also known as algebraic data types (ADTs).","sidebar":"docsSidebar"},"capabilities/gen-constructor":{"id":"capabilities/gen-constructor","title":"GenConstructor","description":"GenConstructor] allows you to use the constructor generation facilities of [[Record] on any type.","sidebar":"docsSidebar"},"capabilities/gen-to-string":{"id":"capabilities/gen-to-string","title":"GenToString","description":"GenToString] allows you to use the ToString generation facilities of [[Record] on any type.","sidebar":"docsSidebar"},"capabilities/implicits/caller-data":{"id":"capabilities/implicits/caller-data","title":"Use Case: CallerData","description":"C# provides us with [CallerMemberNameAttribute], [CallerFilePathAttribute] and [CallerLineNumberAttribute] to get compile time information about where the function is being called from.","sidebar":"docsSidebar"},"capabilities/implicits/dependency-injection":{"id":"capabilities/implicits/dependency-injection","title":"Use Case: Dependency Injection","description":"Lets say we have this code:","sidebar":"docsSidebar"},"capabilities/implicits/index":{"id":"capabilities/implicits/index","title":"Implicits","description":"Implicits are a feature that we have ported from the Scala language. They are a way to resolve function parameter values without providing them explicitly.","sidebar":"docsSidebar"},"capabilities/implicits/library-design":{"id":"capabilities/implicits/library-design","title":"Use Case: Library Design","description":"Having implicit resolution in the language opens us new interesting paths on how to design developer-friendly libraries in C#.","sidebar":"docsSidebar"},"capabilities/index":{"id":"capabilities/index","title":"Compiler Capabilities","description":"This section describes what our extended C# compiler is capable of.","sidebar":"docsSidebar"},"capabilities/lazy-property":{"id":"capabilities/lazy-property","title":"LazyProperty","description":"[LazyProperty] makes the property calculated only on first access and then cached as a field in the type.","sidebar":"docsSidebar"},"capabilities/macros/attribute-based/expression-macro":{"id":"capabilities/macros/attribute-based/expression-macro","title":"ExpressionMacro","description":"[ExpressionMacro] is an attribute that allows you to replace the invocation of a function with a specified body that returns an expression.","sidebar":"docsSidebar"},"capabilities/macros/attribute-based/index":{"id":"capabilities/macros/attribute-based/index","title":"Attribute-Based Macros","description":"Attribute-based macros are attached to types or methods.","sidebar":"docsSidebar"},"capabilities/macros/attribute-based/macro-exception":{"id":"capabilities/macros/attribute-based/macro-exception","title":"MacroException","description":"When you use an attribute-based macro the body of the function gets replaced. However, the C# compiler still requires us to provide some body for the function, even if it will get thrown out.","sidebar":"docsSidebar"},"capabilities/macros/attribute-based/parameters-and-functions":{"id":"capabilities/macros/attribute-based/parameters-and-functions","title":"Parameters and Functions","description":"Both expression and statement macros share the same parameters and functions that you can use in them.","sidebar":"docsSidebar"},"capabilities/macros/attribute-based/statement-macro":{"id":"capabilities/macros/attribute-based/statement-macro","title":"StatementMacro","description":"StatementMacro] is very similar to [[ExpressionMacro], however where [ExpressionMacro] produces expressions, [StatementMacro] produces statements.","sidebar":"docsSidebar"},"capabilities/macros/attribute-based/use-cases":{"id":"capabilities/macros/attribute-based/use-cases","title":"Use Cases","description":"Expression and statement macros are incredibly useful in these scenarios.","sidebar":"docsSidebar"},"capabilities/macros/csharp-based/index":{"id":"capabilities/macros/csharp-based/index","title":"TODO: C#-Based Macros","description":"-Based Macros","sidebar":"docsSidebar"},"capabilities/macros/csharp-compilation-process":{"id":"capabilities/macros/csharp-compilation-process","title":"C# Compilation Process","description":"Compilation Process","sidebar":"docsSidebar"},"capabilities/macros/index":{"id":"capabilities/macros/index","title":"Macros","description":"Macros are programs that are ran during the compilation. These programs get access to the source code that is being compiled and can do anything that a regular program does. They can:","sidebar":"docsSidebar"},"capabilities/macros/inlining":{"id":"capabilities/macros/inlining","title":"Inlining","description":"This is a general overview of inlining, which is a process of taking a function call and putting the code from that directly at the call-site, instead of calling a function. After inlining the inlined function does not exist anymore in the code.","sidebar":"docsSidebar"},"capabilities/macros/scriban-based/index":{"id":"capabilities/macros/scriban-based/index","title":"TODO: Scriban-Based Macros","description":"TODO","sidebar":"docsSidebar"},"capabilities/record/index":{"id":"capabilities/record/index","title":"Record","description":"C# 9 introduced record types into the language, while C# 10 added support for struct records as well.","sidebar":"docsSidebar"},"capabilities/record/record-type":{"id":"capabilities/record/record-type","title":"RecordType","description":"Currently if the type that is included in the record is generated by the compiler (for example, from a macro), the compiler will not be able to compile such a record without us providing additional information.","sidebar":"docsSidebar"},"generation-and-transformation/index":{"id":"generation-and-transformation/index","title":"Code Generation vs Transformation","description":"Our compiler can do two things:","sidebar":"docsSidebar"},"intro":{"id":"intro","title":"TODO: Introduction","description":"TODO","sidebar":"docsSidebar"},"macro-library/index":{"id":"macro-library/index","title":"Macro Library","description":"Scriban-based and C#-based macros allow us to do a lot of things that would otherwise only be possible as compiler extensions.","sidebar":"docsSidebar"},"macro-library/singleton":{"id":"macro-library/singleton","title":"TODO: Singleton","description":"","sidebar":"docsSidebar"},"supported-targets":{"id":"supported-targets","title":"TODO: Supported Targets","description":"TODO: any .NET framework or Core project + Unity","sidebar":"docsSidebar"}}}')}}]);